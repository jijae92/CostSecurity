"""Cost Explorer client with retry, timeout, and sample data support."""

from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List

import boto3
from botocore.config import Config
from botocore.exceptions import BotoCoreError, ClientError
from tenacity import RetryError, retry, retry_if_exception_type, stop_after_attempt, wait_exponential_jitter

from src.common.log import get_logger

LOGGER = get_logger(__name__)


@dataclass(slots=True)
class CostExplorerClient:
    """Wrapper around the AWS Cost Explorer API."""

    client: Any
    sample_data_root: Path
    dry_run: bool

    @classmethod
    def from_config(cls, config: "AppConfig") -> "CostExplorerClient":
        """Build the client using shared configuration."""
        session = boto3.session.Session(region_name=config.aws_region)
        boto_config = Config(connect_timeout=10, read_timeout=10, retries={"max_attempts": 3})
        ce_client = session.client("ce", config=boto_config)
        return cls(client=ce_client, sample_data_root=config.sample_data_path, dry_run=config.dry_run)

    def load_costs(self, *, time_period: Dict[str, str], group_by: List[Dict[str, str]]) -> Dict[str, Any]:
        """Retrieve costs using Cost Explorer or sample data in dry-run mode."""
        if self.dry_run:
            LOGGER.debug("Loading cost data from sample dataset.")
            return self._load_sample("cost_explorer_sample.json")

        try:
            response = self._call_cost_explorer(time_period=time_period, group_by=group_by)
            return response
        except RetryError as exc:
            LOGGER.error("Cost Explorer request exhausted retries", extra={"time_period": time_period})
            raise RuntimeError("Cost Explorer API unavailable; retry later.") from exc

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential_jitter(exp_base=2, max=10),
        retry=retry_if_exception_type((ClientError, BotoCoreError)),
        reraise=True,
    )
    def _call_cost_explorer(self, *, time_period: Dict[str, str], group_by: List[Dict[str, str]]) -> Dict[str, Any]:
        LOGGER.info("Requesting cost data", extra={"start": time_period.get("Start"), "end": time_period.get("End")})
        return self.client.get_cost_and_usage(
            TimePeriod=time_period,
            Metrics=["BlendedCost", "UsageQuantity"],
            Granularity="DAILY",
            GroupBy=group_by,
        )

    def _load_sample(self, filename: str) -> Dict[str, Any]:
        sample_path = self.sample_data_root / filename
        if not sample_path.exists():
            raise FileNotFoundError(f"Sample data file missing: {sample_path}")
        LOGGER.debug("Reading sample file", extra={"path": str(sample_path)})
        with sample_path.open("r", encoding="utf-8") as handler:
            return json.load(handler)


# Avoid circular import at module level
from src.common.config import AppConfig  # noqa: E402  pylint: disable=wrong-import-position
